<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0025)http://nemerle.org/About/ -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>
	Nemerle for OOP Programmers Week 3
</title>
    <link type="text/css" rel="stylesheet" href="static/style.css">
    <link type="text/css" rel="stylesheet" href="static/theme-default.css">
    <link type="text/css" rel="stylesheet" href="static/pygments.css">
<body>
        <table border="0" cellpadding="0" cellspacing="0">
            <tbody><tr class="header">
                <td>
                    <table border="0" cellpadding="0" cellspacing="0">
                        <tbody><tr>
                            <td width="100px"></td>
                            <td>
                                <table border="0" cellpadding="0" cellspacing="0">
                                    <tbody><tr>
                                        <td width="110px"></td>
                                        <td width="170px">
                                            <a href="./static/About - Nemerle programming language official site.htm"><img src="./static/logo.png"></a>
                                        </td>
                                        <td width="31px">
                                            <a href="./static/About - Nemerle programming language official site.htm"><img src="./static/ribbon.png"></a>
                                        </td>
                                        <td align="right" valign="bottom">
                                            <table border="0" cellpadding="0" cellspacing="0" class="menubar">
                                                <tbody><tr height="36">
                                                    <td class="menuitem">
                                                        <a href="http://nemerle.org/About/#"><img src="./static/menuitem-about-active-foreground.png"></a>
                                                    </td>
                                                    <td class="menuitem">
                                                        <a href="http://nemerle.org/wiki/index.php?title=Main_Page"><img src="./static/menuitem-wiki-inactive-foreground.png"></a>
                                                    </td>
                                                    <td class="menuitem">
                                                        <a href="http://groups.google.com/group/nemerle-en"><img src="./static/menuitem-forum-inactive-foreground.png"></a>
                                                    </td>
                                                    <td class="menuitem">
                                                        <a href="http://code.google.com/p/nemerle/downloads/list"><img src="./static/menuitem-downloads-inactive-foreground.png"></a>
                                                    </td>
                                                    <td>
                                                        <a href=""><img src="./static/menuitem-search-inactive-foreground.png"></a>
                                                    </td>
                                                </tr>
                                                <tr height="8">
                                                    <td colspan="4"></td>
                                                </tr>
                                            </tbody></table>
                                        </td>
                                    </tr>
                                </tbody></table>
                            </td>
                            <td width="100px">
                            </td>
                        </tr>
                    </tbody></table>
                </td>
            </tr>
            <tr class="body">
                <td>
                    <table border="0" cellpadding="0" cellspacing="0">
                        <tbody><tr>
                            <td width="100px">
                                &nbsp;
                            </td>
                            <td class="content">
                                <div>
                                    
<div align="right">
</div>

<p>
This week we will learn more about functional programming in Nemerle.&#xD;
We will find out about tuples, variants, and advanced pattern matching.  &#xD;</p>

<table id="toc" class="toc" summary="Contents"><tr><td><div>Table of Contents</div><ul><li><a href="#Tuples">Tuples</a><ul><li><a href="#Tuple_pattern">Tuple pattern</a></li><li><a href="#Tuple_indexer">Tuple indexer</a><ul><li><a href="#Indexing_rules">Indexing rules</a></li></ul></li><li><a href="#Tuple_type">Tuple type</a></li><li><a href="#Side_note_relationship_between_tuple_and_function_types">Side note: relationship between tuple and function types</a></li><li><a href="#Side_note_tuple_assignment">Side note: tuple assignment</a></li></ul></li><li><a href="#Variants">Variants</a><ul><li><a href="#Matching_over_variants">Matching over variants</a></li><li><a href="#Using_variants_as_trees">Using variants as trees</a></li><li><a href="#XML_trees">XML trees</a></li><li><a href="#Side_note_skipping_codematchcode">Side note: skipping <code>match</code></a></li></ul></li><li><a href="#Exercises">Exercises</a><ul><li><a href="#Exercise_1_TreeIter">Exercise 1: Tree.Iter</a></li><li><a href="#Exercise_2_XML_parsing">Exercise 2: XML parsing</a></li></ul></li></ul></td></tr></table><h2><span class="mw-headline" id="Tuples"><a name="Tuples" id="Tuples">Tuples</a></span></h2>

<p>Tuples in Nemerle are similar to tuples in math, or in SQL for that &#xD;
matter. They are immutable, heterogeneous (a tuple can hold values of &#xD;
several types at once) finite sequences of objects. The most common &#xD;
examples of tuples is a pair or triple:&#xD;
</p><div class="highlight"><pre><span class="k">def</span> <span class="n">our_pair</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">);</span>
<span class="k">def</span> <span class="n">our_triple</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">12</span><span class="p">,</span> <span class="p">-</span><span class="m">10</span><span class="p">);</span>
</pre>
</div>


<p>Up to 9 elements can be held in a tuple (the syntax looks clumsy for &#xD;
5 or 6 elements already, and you cannot use loops for iterating over&#xD;
tuples).&#xD;</p>

<p>A tuple can hold values of several types:&#xD;
</p><div class="highlight"><pre><span class="k">def</span> <span class="n">another_pair</span> <span class="p">=</span> <span class="p">(</span><span class="s">"foo"</span><span class="p">,</span> <span class="m">3.0</span><span class="p">);</span>
</pre>
</div>


<p>Tuples are useful for returning multiple values from functions or holding &#xD;
several things in a single cell in containers. One can always use &#xD;
record-like classes, however this requires additional hassle of a&#xD;
separate class definition.&#xD;</p>

<h3><span class="mw-headline" id="Tuple_pattern"><a name="Tuple_pattern" id="Tuple_pattern">Tuple pattern</a></span></h3>

<p>The most common way of decomposing a tuple is by using a tuple pattern.&#xD;
It looks mostly like the tuple definition:&#xD;</p>

<div class="highlight"><pre><span class="k">def</span> <span class="nf">divmod</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">def</span> <span class="n">div</span> <span class="p">=</span> <span class="n">x</span> <span class="p">/</span> <span class="n">y</span><span class="p">;</span>
  <span class="k">def</span> <span class="n">mod</span> <span class="p">=</span> <span class="n">x</span> <span class="p">%</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">(</span><span class="n">div</span><span class="p">,</span> <span class="n">mod</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">match</span> <span class="p">(</span><span class="n">divmod</span> <span class="p">(</span><span class="m">142</span><span class="p">,</span> <span class="m">13</span><span class="p">))</span> <span class="p">{</span>
  <span class="p">|</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">=&gt;</span>
    <span class="n">System</span><span class="p">.</span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span> <span class="p">(</span><span class="s">$ "div=</span><span class="n">$d</span><span class="s">, mod=</span><span class="n">$m</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Output: div=10, mod=12</span>
</pre>
</div>


<p>Here we define a local function -- introduced in Week 2 -- called <code>divmod</code>, &#xD;
which returns the tuple <code>(div, mod)</code>. The result is then matched &#xD;
against a tuple pattern. As you can see, the pattern binds the first &#xD;
element of the tuple to <code>d</code> and the second to <code>m</code>.&#xD;</p>

<p>Single-case matching has a special, shorter syntax in Nemerle, as shown here:&#xD;
</p><div class="highlight"><pre><span class="k">def</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">=</span> <span class="n">divmod</span> <span class="p">(</span><span class="m">142</span><span class="p">,</span> <span class="m">13</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span> <span class="p">(</span><span class="s">$ "div=</span><span class="n">$d</span><span class="s">, mod=</span><span class="n">$m</span><span class="s">"</span><span class="p">);</span>
</pre>
</div>


<p>The <code>divmod</code> function could be written more compactly as well:&#xD;
</p><div class="highlight"><pre><span class="k">def</span> <span class="nf">divmod</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="n">x</span> <span class="p">/</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="p">%</span> <span class="n">y</span><span class="p">)</span>
<span class="p">}</span>
</pre>
</div>


<p>The arguments to the tuple constructor are just expressions, and &#xD;
the names <code>div</code> and <code>mod</code> used for elements didn't&#xD;
really matter.&#xD;</p>

<h3><span class="mw-headline" id="Tuple_indexer"><a name="Tuple_indexer" id="Tuple_indexer">Tuple indexer</a></span></h3>

<p>For cases where pattern matching doesn't seem right (for example, you&#xD;
want just the first element of a tuple returned by a nested call),&#xD;
there is a special tuple indexer. Using it, the example above could be &#xD;
rewritten as:&#xD;
</p><div class="highlight"><pre><span class="k">def</span> <span class="nf">divmod</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="n">x</span> <span class="p">/</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="p">%</span> <span class="n">y</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">def</span> <span class="n">r</span> <span class="p">=</span> <span class="n">divmod</span> <span class="p">(</span><span class="m">142</span><span class="p">,</span> <span class="m">13</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span> <span class="p">(</span><span class="s">$ "div=</span><span class="n">$</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="err">0</span><span class="p">])</span><span class="s">, mod=</span><span class="n">$</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="err">1</span><span class="p">])</span><span class="s">"</span><span class="p">);</span>
</pre>
</div>


<p>Now, the tuple result gets assigned to <code>r</code>, and the <code>$</code> macro &#xD;
expands it's elements by index. As with arrays, tuple indexing is 0-based &#xD;
(the first element of a tuple has index 0).&#xD;</p>

<h4><span class="mw-headline" id="Indexing_rules"><a name="Indexing_rules" id="Indexing_rules">Indexing rules</a></span></h4>

<p>In case tuples have started to look too much like arrays, here are some &#xD;
rules about tuple indexers to help clarify things. &#xD;</p>

<p>Unlike an array indexer, it is <b>not</b> possible to supply anything beside a constant to the tuple indexer. For example, the following code will not work:&#xD;
</p><div class="highlight"><pre><span class="k">def</span> <span class="n">pair</span> <span class="p">=</span> <span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">);</span>
<span class="k">def</span> <span class="n">idx</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">Parse</span> <span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span> <span class="p">());</span>
<span class="k">def</span> <span class="n">element</span> <span class="p">=</span> <span class="n">pair</span> <span class="p">[</span><span class="n">idx</span><span class="p">];</span> <span class="c1">// dynamic access is invalid</span>
</pre>
</div>


<p>In this contrived example, it should be clear why this is prohibited: &#xD;
depending on user input the type of <code>element</code> would be <code>string</code>&#xD;
or <code>int</code>. The only solution would be to use a compile-time type &#xD;
of <code>object</code> for <code>element</code>, however we felt that this &#xD;
wouldn't be useful enough to mandate implementation.&#xD;</p>

<p>Because tuples are immutable, you also <b>cannot</b> assign values to tuple elements, as in:&#xD;
</p><div class="highlight"><pre><span class="k">def</span> <span class="n">p</span> <span class="p">=</span> <span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">);</span>
<span class="n">p</span> <span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="m">17</span><span class="p">;</span> <span class="c1">// incorrect assignment to tuple</span>
</pre>
</div>


<h3><span class="mw-headline" id="Tuple_type"><a name="Tuple_type" id="Tuple_type">Tuple type</a></span></h3>

<p>The constructor of tuple types is the star (<code>*</code>). For example&#xD;
the tuple <code>("foo", 42, 3.1415)</code> has type <code>string * int *&#xD;double</code>. This notion comes from math, where the times (&#xD7;) symbol&#xD;
is used, as in dimensions L &#xD7; W &#xD7; H.&#xD;</p>

<p>A fully-typed standalone version of <code>divmod</code> would look like: &#xD;</p>

<div class="highlight"><pre><span class="k">static</span> <span class="nf">divmod</span> <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">y</span> <span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">:</span> <span class="kt">int</span> <span class="p">*</span> <span class="kt">int</span> <span class="p">{</span>
   <span class="p">(</span><span class="n">x</span> <span class="p">/</span> <span class="n">y</span> <span class="p">,</span> <span class="n">x</span> <span class="p">%</span> <span class="n">y</span><span class="p">)</span>
<span class="p">}</span>
</pre>
</div>


<h3><span class="mw-headline" id="Side_note_relationship_between_tuple_and_function_types"><a name="Side_note_relationship_between_tuple_and_function_types" id="Side_note_relationship_between_tuple_and_function_types">Side note: relationship between tuple and function types</a></span></h3>

<p>The tuple type constructor is also used in function types, which is&#xD;
not an accident. We consider a function taking more than one argument&#xD;
exactly the same as a function taking a single tuple argument of the&#xD;
corresponding type. For example the following code is perfectly valid:&#xD;</p>

<div class="highlight"><pre><span class="k">def</span> <span class="nf">print_two_ints</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">System</span><span class="p">.</span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span> <span class="p">(</span><span class="s">$ "first=</span><span class="n">$x</span><span class="s">, second=</span><span class="n">$y</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">def</span> <span class="nf">divmod</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="n">x</span> <span class="p">/</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="p">%</span> <span class="n">y</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">print_two_ints</span> <span class="p">(</span><span class="n">divmod</span> <span class="p">(</span><span class="m">143</span><span class="p">,</span> <span class="m">77</span><span class="p">))</span>
</pre>
</div>


<h3><span class="mw-headline" id="Side_note_tuple_assignment"><a name="Side_note_tuple_assignment" id="Side_note_tuple_assignment">Side note: tuple assignment</a></span></h3>

<p>Nemerle supports multiple assignment. That is, one can use a <i>pseudo-tuple</i> &#xD;
of possible assignment targets. For example:&#xD;</p>

<div class="highlight"><pre><span class="k">mutable</span> <span class="n">x</span> <span class="p">=</span> <span class="m">17</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="m">32</span><span class="p">;</span>
<span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>          <span class="c1">// swap x and y</span>
<span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="n">y</span> <span class="p">+</span> <span class="m">12</span><span class="p">,</span> <span class="m">2</span> <span class="p">*</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// or even change their values</span>
</pre>
</div>


<p>All the source expressions are evaluated first and the assignment is done&#xD;
afterwards (this is why the swap works fine).&#xD;</p>

<h2><span class="mw-headline" id="Variants"><a name="Variants" id="Variants">Variants</a></span></h2>

<p>This section borrows some text from the <a class="internal present" href="/Grokking-Nemerle.html">Grokking Nemerle</a> tutorial.&#xD;</p>

<p>Variants (called data types or sum types in <a target="_blank" href="http://www.smlnj.org">SML</a> &#xD;
and <a target="_blank" href="http://www.ocaml.org/">OCaml</a>) are forms of expressing data of several&#xD;
different kinds.&#xD;</p>

<p>The simplest example of variants are enum types known from C (or C#).&#xD;</p>

<p>&lt;c&gt;// C&#xD;enum Color {&#xD;  Red, &#xD;  Yellow, &#xD;  Green &#xD;}&#xD;&lt;/c&gt;&#xD;</p>

<p>You can define C#-like <code>enum</code> types in Nemerle too,&#xD;
but we will talk about it next week. Now let us look at the simplest variant&#xD;
type: &#xD;</p>

<div class="highlight"><pre><span class="c1">// Nemerle</span>
<span class="k">variant</span> <span class="nc">Color</span> <span class="p">{</span>
   <span class="p">|</span> <span class="n">Red</span>
   <span class="p">|</span> <span class="n">Yellow</span>
   <span class="p">|</span> <span class="n">Green</span>
<span class="p">}</span>
</pre>
</div>


<p>However, the variant options might be more useful because they can carry&#xD;
some extra data with them:&#xD;</p>

<div class="highlight"><pre><span class="k">variant</span> <span class="nc">Color</span> <span class="p">{</span>
  <span class="p">|</span> <span class="n">Red</span>
  <span class="p">|</span> <span class="n">Yellow</span>
  <span class="p">|</span> <span class="n">Green</span>
  <span class="p">|</span> <span class="n">Different</span> <span class="p">{</span>
      <span class="n">red</span> <span class="p">:</span> <span class="kt">float</span><span class="p">;</span>
      <span class="n">green</span> <span class="p">:</span> <span class="kt">float</span><span class="p">;</span>
      <span class="n">blue</span> <span class="p">:</span> <span class="kt">float</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>


<p>So if the color is neither red, yellow nor green, it can be represented&#xD;
with RGB. You can create variant objects just like any other object,&#xD;
by using its constructor. All variant options have an implicit&#xD;
<code>[Record]</code> macro invocation on them. We talked about this macro 2 weeks&#xD;
ago, it adds a constructor assigning to each field of a class:&#xD;
</p><div class="highlight"><pre><span class="k">def</span> <span class="n">blue</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Different</span> <span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span>
<span class="k">def</span> <span class="n">red</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Red</span> <span class="p">();</span>
</pre>
</div>


<p>In the OO world, modeling variants with sub classing can sometimes be seen:&#xD;</p>

<div class="highlight"><pre><span class="c1">// C#</span>
<span class="k">class</span> <span class="nc">Color</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">Red</span> <span class="p">:</span> <span class="n">Color</span> <span class="p">{</span> <span class="p">}</span>
  <span class="k">class</span> <span class="nc">Green</span> <span class="p">:</span> <span class="n">Color</span> <span class="p">{</span> <span class="p">}</span>
  <span class="k">class</span> <span class="nc">Yellow</span> <span class="p">:</span> <span class="n">Color</span> <span class="p">{</span> <span class="p">}</span>
  <span class="k">class</span> <span class="nc">Different</span> <span class="p">:</span> <span class="n">Color</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">red</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">green</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">blue</span><span class="p">;</span>
  
    <span class="k">public</span> <span class="nf">Different</span> <span class="p">(</span><span class="kt">float</span> <span class="n">red</span><span class="p">,</span> <span class="kt">float</span> <span class="n">green</span><span class="p">,</span> <span class="kt">float</span> <span class="n">blue</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="n">red</span> <span class="p">=</span> <span class="n">red</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="n">green</span> <span class="p">=</span> <span class="n">green</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="n">blue</span> <span class="p">=</span> <span class="n">blue</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>


<p>Of course, you need to write a constructor, mark fields as public, and &#xD;
so on. When you're done -- using this kind of stuff can get quite &#xD;
involved -- you will need to use lots of runtime type checks.&#xD;</p>

<p>On the other hand, Nemerle provides an easy and convenient method of&#xD;
dealing with variants -- pattern matching.&#xD;</p>

<h3><span class="mw-headline" id="Matching_over_variants"><a name="Matching_over_variants" id="Matching_over_variants">Matching over variants</a></span></h3>

<p>We already used pattern matching on lists, so you can imagine doing a&#xD;
switch over variant options.  For example, a function returning string&#xD;
representation of a color could look like this:&#xD;</p>

<div class="highlight"><pre><span class="k">variant</span> <span class="nc">Color</span> <span class="p">{</span>
  <span class="p">|</span> <span class="n">Red</span>
  <span class="p">|</span> <span class="n">Yellow</span>
  <span class="p">|</span> <span class="n">Green</span>
  <span class="p">|</span> <span class="n">Different</span> <span class="p">{</span>
      <span class="n">red</span> <span class="p">:</span> <span class="kt">float</span><span class="p">;</span>
      <span class="n">green</span> <span class="p">:</span> <span class="kt">float</span><span class="p">;</span>
      <span class="n">blue</span> <span class="p">:</span> <span class="kt">float</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">string_of_color</span> <span class="p">(</span><span class="n">color</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">match</span> <span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">|</span> <span class="n">Color</span><span class="p">.</span><span class="n">Red</span> <span class="p">=&gt;</span> <span class="s">"red"</span>
    <span class="p">|</span> <span class="n">Color</span><span class="p">.</span><span class="n">Yellow</span> <span class="p">=&gt;</span> <span class="s">"yellow"</span>
    <span class="p">|</span> <span class="n">Color</span><span class="p">.</span><span class="n">Green</span> <span class="p">=&gt;</span> <span class="s">"green"</span>
    <span class="p">|</span> <span class="n">Color</span><span class="p">.</span><span class="n">Different</span> <span class="p">(</span><span class="n">red</span> <span class="p">=</span> <span class="n">r</span><span class="p">,</span> <span class="n">green</span> <span class="p">=</span> <span class="n">g</span><span class="p">,</span> <span class="n">blue</span> <span class="p">=</span> <span class="n">b</span><span class="p">)</span> <span class="p">=&gt;</span> 
      <span class="s">$ "rgb(</span><span class="n">$r</span><span class="s">, </span><span class="n">$g</span><span class="s">, </span><span class="n">$b</span><span class="s">)"</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">System</span><span class="p">.</span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span> <span class="p">(</span><span class="n">string_of_color</span> <span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Red</span> <span class="p">()));</span>
<span class="n">System</span><span class="p">.</span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span> <span class="p">(</span><span class="n">string_of_color</span> <span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Different</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">)));</span>

<span class="cm">/* Output:</span>
<span class="cm">red</span>
<span class="cm">rgb(1, 1, 0)</span>
<span class="cm">*/</span>
</pre>
</div>


<p>The first three patterns state we're not interested in any possible fields&#xD;
in the case of <code>Red</code>, <code>Yellow</code> and <code>Green</code>. The last&#xD;
pattern, for the <code>Different</code> case, binds values of the <code>red</code>, &#xD;
<code>green</code> and <code>blue</code> to <code>r</code>, <code>g</code> and <code>b</code> &#xD;
respectively. You can omit matched fields at will, as well as change &#xD;
the ordering.&#xD;</p>

<p>It is also possible to use a shortcut here:&#xD;</p>

<div class="highlight"><pre><span class="p">|</span> <span class="n">Color</span><span class="p">.</span><span class="n">Different</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">=&gt;</span>
</pre>
</div>


<p>This is only available when you specify all the fields in the given object, &#xD;
and in the right order.&#xD;</p>

<h3><span class="mw-headline" id="Using_variants_as_trees"><a name="Using_variants_as_trees" id="Using_variants_as_trees">Using variants as trees</a></span></h3>

<p>The example above, while simple, is not the best usage of variants. &#xD;
Variants are best at handling tree-like data structures. A common &#xD;
example of tree data structures are XML documents. However, we will &#xD;
deal with plain binary trees first.&#xD;</p>

<p>The following example defines the type of trees of integers (representing&#xD;
sets).&#xD;</p>

<div class="highlight"><pre><span class="k">variant</span> <span class="nc">Tree</span> <span class="p">{</span>
  <span class="p">|</span> <span class="n">Node</span> <span class="p">{</span>
      <span class="n">left</span>  <span class="p">:</span> <span class="n">Tree</span><span class="p">;</span>
      <span class="n">elem</span>  <span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
      <span class="n">right</span> <span class="p">:</span> <span class="n">Tree</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">|</span> <span class="n">Null</span>

  <span class="k">public</span> <span class="k">override</span> <span class="nf">ToString</span> <span class="p">()</span> <span class="p">:</span> <span class="kt">string</span>
  <span class="p">{</span>
    <span class="k">match</span> <span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">|</span> <span class="n">Tree</span><span class="p">.</span><span class="n">Node</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="s">$ "(</span><span class="n">$l</span><span class="s"> </span><span class="n">$e</span><span class="s"> </span><span class="n">$r</span><span class="s">)"</span>
      <span class="p">|</span> <span class="n">Tree</span><span class="p">.</span><span class="n">Null</span> <span class="p">=&gt;</span> <span class="s">"."</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>


<p>So a tree node is either an inside node with an element and two subtrees&#xD;
or a null tree without any elements inside. We have also overridden the&#xD;
<code>ToString</code> method, so the <code>$</code> macro and <code>WriteLine</code> &#xD;
work properly on trees (the default implementation would yield &#xD;
<code>"Tree.Node"</code> or <code>"Tree.Null"</code> only).&#xD;</p>

<p>We can now define a method for inserting elements to the tree. It should&#xD;
be defined inside the <code>Tree</code> variant:&#xD;</p>

<div class="highlight"><pre><span class="k">public</span> <span class="nf">Insert</span> <span class="p">(</span><span class="n">e</span> <span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">:</span> <span class="n">Tree</span>
<span class="p">{</span>
  <span class="k">match</span> <span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">|</span> <span class="n">Tree</span><span class="p">.</span><span class="n">Node</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="p">=&gt;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="p">&lt;</span> <span class="n">cur</span><span class="p">)</span>
        <span class="n">Tree</span><span class="p">.</span><span class="n">Node</span> <span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">Insert</span> <span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">cur</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
      <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">e</span> <span class="p">&gt;</span> <span class="n">cur</span><span class="p">)</span>
        <span class="n">Tree</span><span class="p">.</span><span class="n">Node</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">Insert</span> <span class="p">(</span><span class="n">e</span><span class="p">))</span>
      <span class="k">else</span>
        <span class="k">this</span>
    <span class="p">|</span> <span class="n">Tree</span><span class="p">.</span><span class="n">Null</span> <span class="p">=&gt;</span>
      <span class="n">Tree</span><span class="p">.</span><span class="n">Node</span> <span class="p">(</span><span class="n">Tree</span><span class="p">.</span><span class="n">Null</span> <span class="p">(),</span> <span class="n">e</span><span class="p">,</span> <span class="n">Tree</span><span class="p">.</span><span class="n">Null</span> <span class="p">())</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>


<p>The function checks if the element to insert is smaller than the element &#xD;
in the current node, and if so, inserts it in the left subtree. If it's &#xD;
bigger, it inserts the element in the right subtree. Otherwise, it has &#xD;
to be equal, so it doesn't insert it again: it just returns the &#xD;
unchanged tree.&#xD;</p>

<p>If the function hits an empty subtree, it creates a new leaf in that place.&#xD;</p>

<p>Having a <code>Contains</code> check wouldn't be a bad idea, either:&#xD;</p>

<div class="highlight"><pre><span class="k">public</span> <span class="nf">Contains</span> <span class="p">(</span><span class="n">e</span> <span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">:</span> <span class="kt">bool</span>
<span class="p">{</span>
  <span class="k">match</span> <span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">|</span> <span class="n">Tree</span><span class="p">.</span><span class="n">Node</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">when</span> <span class="n">e</span> <span class="p">&lt;</span> <span class="n">cur</span> <span class="p">=&gt;</span> 
      <span class="n">l</span><span class="p">.</span><span class="n">Contains</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span>

    <span class="p">|</span> <span class="n">Tree</span><span class="p">.</span><span class="n">Node</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">when</span> <span class="n">e</span> <span class="p">&gt;</span> <span class="n">cur</span> <span class="p">=&gt;</span> 
      <span class="n">r</span><span class="p">.</span><span class="n">Contains</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span>

    <span class="p">|</span> <span class="n">Tree</span><span class="p">.</span><span class="n">Node</span> <span class="p">=&gt;</span> <span class="k">true</span>
    <span class="p">|</span> <span class="n">Tree</span><span class="p">.</span><span class="n">Null</span> <span class="p">=&gt;</span> <span class="k">false</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>


<p>This function works much like insert -- it checks if the element &#xD;
could be found in the left or in the right subtree, and looks for &#xD;
it there. If not, either it has found the matching node, or null, &#xD;
and returns the appropriate result.&#xD;</p>

<p>There is however one new feature used here -- <code>when</code> guards&#xD;
in matching. Any matching clause can have an additional condition &#xD;
attached. The function first checks if the pattern matches the value, &#xD;
and if so, the condition is evaluated. If that yields true, the given &#xD;
branch is taken, otherwise it proceeds with further match clauses.&#xD;</p>

<p>This example could also be written with regular <code>if</code>s:&#xD;</p>

<div class="highlight"><pre><span class="k">public</span> <span class="nf">Contains</span> <span class="p">(</span><span class="n">e</span> <span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">:</span> <span class="kt">bool</span>
<span class="p">{</span>
  <span class="k">match</span> <span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">|</span> <span class="n">Tree</span><span class="p">.</span><span class="n">Node</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="p">=&gt;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="p">&lt;</span> <span class="n">cur</span><span class="p">)</span>
        <span class="n">l</span><span class="p">.</span><span class="n">Contains</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">e</span> <span class="p">&gt;</span> <span class="n">cur</span><span class="p">)</span>
        <span class="n">r</span><span class="p">.</span><span class="n">Contains</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="k">else</span>
  <span class="k">true</span>

    <span class="p">|</span> <span class="n">Tree</span><span class="p">.</span><span class="n">Null</span> <span class="p">=&gt;</span> <span class="k">false</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>


<p>Finally we can test our example:&#xD;</p>

<div class="highlight"><pre><span class="c1">// we start with an empty tree</span>
<span class="k">def</span> <span class="n">t</span> <span class="p">=</span> <span class="n">Tree</span><span class="p">.</span><span class="n">Null</span> <span class="p">();</span>
<span class="c1">// add a few elements</span>
<span class="k">def</span> <span class="n">t</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="n">Insert</span> <span class="p">(</span><span class="m">13</span><span class="p">).</span><span class="n">Insert</span> <span class="p">(</span><span class="m">34</span><span class="p">).</span><span class="n">Insert</span> <span class="p">(</span><span class="m">23</span><span class="p">);</span>
<span class="c1">// and display it</span>
<span class="n">System</span><span class="p">.</span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span> <span class="p">(</span><span class="n">t</span><span class="p">);</span> 
<span class="n">System</span><span class="p">.</span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">Contains</span> <span class="p">(</span><span class="m">13</span><span class="p">));</span> 
<span class="n">System</span><span class="p">.</span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">Contains</span> <span class="p">(</span><span class="m">42</span><span class="p">));</span> 

<span class="cm">/* Output:</span>
<span class="cm">(. 13 ((. 23 .) 34 .))</span>
<span class="cm">True</span>
<span class="cm">False</span>
<span class="cm">*/</span>
</pre>
</div>


<h3><span class="mw-headline" id="XML_trees"><a name="XML_trees" id="XML_trees">XML trees</a></span></h3>

<p>As you can see binary trees are not very interesting, so we will go &#xD;
on to XML. Whether XML is interesting remains a doubtful question, &#xD;
but at least it is somewhat more practical.&#xD;</p>

<div class="highlight"><pre><span class="k">variant</span> <span class="nc">Node</span> <span class="p">{</span>
  <span class="p">|</span> <span class="n">Text</span> <span class="p">{</span> 
      <span class="n">value</span> <span class="p">:</span> <span class="kt">string</span><span class="p">;</span> 
    <span class="p">}</span>
  <span class="p">|</span> <span class="n">Element</span> <span class="p">{</span>
      <span class="n">name</span> <span class="p">:</span> <span class="kt">string</span><span class="p">;</span> 
      <span class="n">children</span> <span class="p">:</span> <span class="kt">list</span> <span class="p">[</span><span class="n">Node</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>


<p>This variant defines a simplistic data structure to hold XML trees. An XML&#xD;
node is either a text node with some specified text inside, or an element&#xD;
node with a name and zero or more children. A sequence of children is &#xD;
represented as a Nemerle list.&#xD;</p>

<p>For example the following tree:&#xD;</p>

<p>&lt;xml&gt;&amp;lt;tree&amp;gt;&#xD;  &amp;amp;lt;branch&amp;amp;gt;&#xD;    &amp;amp;amp;lt;leaf&amp;amp;amp;gt;&amp;amp;amp;lt;/leaf&amp;amp;amp;gt;&#xD;  &amp;amp;lt;/branch&amp;amp;gt;&#xD;  &amp;amp;lt;branch&amp;amp;gt;&#xD;    Foo&#xD;  &amp;amp;lt;/branch&amp;amp;gt;&#xD;&amp;lt;/tree&amp;gt;&#xD;&lt;/xml&gt;&#xD;</p>

<p>would be represented by:&#xD;</p>

<div class="highlight"><pre><span class="n">Node</span><span class="p">.</span><span class="n">Element</span> <span class="p">(</span><span class="s">"tree"</span><span class="p">,</span> 
<span class="na">  [Node.Element ("branch", [Node.Element ("leaf", []</span><span class="p">)]),</span>
   <span class="n">Node</span><span class="p">.</span><span class="n">Element</span> <span class="p">(</span><span class="s">"branch"</span><span class="p">,</span> <span class="p">[</span><span class="n">Node</span><span class="p">.</span><span class="n">Text</span> <span class="p">(</span><span class="s">"Foo"</span><span class="p">)])])</span>
</pre>
</div>


<p>Of course XML by itself is just a data format. Using data in the&#xD;
above form wouldn't be too easy. So we want some different internal&#xD;
representation of data, and use XML only to save it or send it over&#xD;
the network.&#xD;</p>

<div class="highlight"><pre><span class="k">variant</span> <span class="nc">RefrigeratorContent</span>
<span class="p">{</span>
  <span class="p">|</span> <span class="n">Beer</span> <span class="p">{</span> <span class="n">name</span> <span class="p">:</span> <span class="kt">string</span><span class="p">;</span> <span class="n">volume</span> <span class="p">:</span> <span class="kt">float</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">|</span> <span class="n">Chips</span> <span class="p">{</span> <span class="n">weight</span> <span class="p">:</span> <span class="kt">int</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">|</span> <span class="n">Ketchup</span>

  <span class="k">public</span> <span class="k">static</span> <span class="nf">FromXml</span> <span class="p">(</span><span class="n">node</span> <span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="p">:</span> <span class="n">RefrigeratorContent</span>
  <span class="p">{</span>
    <span class="k">match</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">|</span> <span class="n">Node</span><span class="p">.</span><span class="n">Element</span> <span class="p">(</span><span class="s">"ketchup"</span><span class="p">,</span> <span class="p">[])</span> <span class="p">=&gt;</span>
        <span class="n">RefrigeratorContent</span><span class="p">.</span><span class="n">Ketchup</span> <span class="p">()</span>
      <span class="p">|</span> <span class="n">Node</span><span class="p">.</span><span class="n">Element</span> <span class="p">(</span><span class="s">"beer"</span><span class="p">,</span> 
<span class="na">          [Node.Element ("name", [Node.Text (name)]</span><span class="p">),</span>
           <span class="n">Node</span><span class="p">.</span><span class="n">Element</span> <span class="p">(</span><span class="s">"volume"</span><span class="p">,</span> <span class="p">[</span><span class="n">Node</span><span class="p">.</span><span class="n">Text</span> <span class="p">(</span><span class="n">volume</span><span class="p">)])])</span> <span class="p">=&gt;</span>
        <span class="n">RefrigeratorContent</span><span class="p">.</span><span class="n">Beer</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kt">float</span><span class="p">.</span><span class="n">Parse</span> <span class="p">(</span><span class="n">volume</span><span class="p">))</span>
      <span class="p">|</span> <span class="n">Node</span><span class="p">.</span><span class="n">Element</span> <span class="p">(</span><span class="s">"chips"</span><span class="p">,</span>
<span class="na">          [Node.Element ("weight", [Node.Text (weight)]</span><span class="p">)])</span> <span class="p">=&gt;</span>
        <span class="n">RefrigeratorContent</span><span class="p">.</span><span class="n">Chips</span> <span class="p">(</span><span class="kt">int</span><span class="p">.</span><span class="n">Parse</span> <span class="p">(</span><span class="n">weight</span><span class="p">))</span>
      <span class="p">|</span> <span class="n">_</span> <span class="p">=&gt;</span>
        <span class="k">throw</span> <span class="n">System</span><span class="p">.</span><span class="n">ArgumentException</span> <span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>


<p>The most interesting thing here are the nested patterns. Until now &#xD;
we have always used very shallow patterns -- we just checked the &#xD;
top-level object and possibly its bound fields. However it is possible &#xD;
to look very deeply in the structure of object. Instead of binding &#xD;
values of fields to variables, this function checks if they match &#xD;
given patterns. This is all that is happening here -- nested patterns.&#xD;</p>

<p>Probably the most annoying thing about the example above is the amount&#xD;
of times you have to say <code>RefrigeratorContent</code> and <code>Node</code>.&#xD;
Fortunately both can be skipped, however for quite different reasons.&#xD;</p>

<p><code>RefrigeratorContent</code> used for object construction can be&#xD;
skipped, because we are in the body of the <code>RefrigeratorContent</code> &#xD;
variant definition. If we wanted to skip it elsewhere, we would have &#xD;
to say <code>using RefrigeratorContent;</code> first.&#xD;</p>

<p>On the other hand, <code>Node</code> in matching can be skipped, because &#xD;
we provided the type of the <code>node</code> parameter in the <code>match</code> &#xD;
statement, therefore the compiler will just look up the appropriate &#xD;
variant options in this type.&#xD;</p>

<p>So the shorter example would be:&#xD;
</p><div class="highlight"><pre><span class="k">variant</span> <span class="nc">RefrigeratorContent</span>
<span class="p">{</span>
  <span class="p">|</span> <span class="n">Beer</span> <span class="p">{</span> <span class="n">name</span> <span class="p">:</span> <span class="kt">string</span><span class="p">;</span> <span class="n">volume</span> <span class="p">:</span> <span class="kt">float</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">|</span> <span class="n">Chips</span> <span class="p">{</span> <span class="n">weight</span> <span class="p">:</span> <span class="kt">int</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">|</span> <span class="n">Ketchup</span>

  <span class="k">public</span> <span class="k">static</span> <span class="nf">FromXml</span> <span class="p">(</span><span class="n">node</span> <span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="p">:</span> <span class="n">RefrigeratorContent</span>
  <span class="p">{</span>
    <span class="k">match</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">|</span> <span class="n">Element</span> <span class="p">(</span><span class="s">"ketchup"</span><span class="p">,</span> <span class="p">[])</span> <span class="p">=&gt;</span> <span class="n">Ketchup</span> <span class="p">()</span>
      <span class="p">|</span> <span class="n">Element</span> <span class="p">(</span><span class="s">"beer"</span><span class="p">,</span> <span class="p">[</span><span class="n">Element</span> <span class="p">(</span><span class="s">"name"</span><span class="p">,</span> <span class="p">[</span><span class="n">Text</span> <span class="p">(</span><span class="n">name</span><span class="p">)]),</span>
                          <span class="n">Element</span> <span class="p">(</span><span class="s">"volume"</span><span class="p">,</span> <span class="p">[</span><span class="n">Text</span> <span class="p">(</span><span class="n">volume</span><span class="p">)])])</span> <span class="p">=&gt;</span>
        <span class="n">Beer</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kt">float</span><span class="p">.</span><span class="n">Parse</span> <span class="p">(</span><span class="n">volume</span><span class="p">))</span>
      <span class="p">|</span> <span class="n">Element</span> <span class="p">(</span><span class="s">"chips"</span><span class="p">,</span> <span class="p">[</span><span class="n">Element</span> <span class="p">(</span><span class="s">"weight"</span><span class="p">,</span> <span class="p">[</span><span class="n">Text</span> <span class="p">(</span><span class="n">weight</span><span class="p">)])])</span> <span class="p">=&gt;</span>
        <span class="n">Chips</span> <span class="p">(</span><span class="kt">int</span><span class="p">.</span><span class="n">Parse</span> <span class="p">(</span><span class="n">weight</span><span class="p">))</span>
      <span class="p">|</span> <span class="n">_</span> <span class="p">=&gt;</span>
        <span class="k">throw</span> <span class="n">System</span><span class="p">.</span><span class="n">ArgumentException</span> <span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>


<p>Once we have something to put into a refrigerator, we can now build&#xD;
the refrigerator.&#xD;</p>

<div class="highlight"><pre><span class="na">[Record]</span>
<span class="k">class</span> <span class="nc">Refrigerator</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="n">minimal_temperature</span> <span class="p">:</span> <span class="kt">float</span><span class="p">;</span>
  <span class="k">public</span> <span class="n">content</span> <span class="p">:</span> <span class="kt">list</span> <span class="p">[</span><span class="n">RefrigeratorContent</span><span class="p">];</span>
  
  <span class="k">public</span> <span class="k">static</span> <span class="nf">FromXml</span> <span class="p">(</span><span class="n">node</span> <span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="p">:</span> <span class="n">Refrigerator</span>
  <span class="p">{</span>
    <span class="k">match</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">|</span> <span class="n">Element</span> <span class="p">(</span><span class="s">"refrigerator"</span><span class="p">,</span> 
          <span class="n">Element</span> <span class="p">(</span><span class="s">"minimal-temperature"</span><span class="p">,</span> <span class="p">[</span><span class="n">Text</span> <span class="p">(</span><span class="n">min_temp</span><span class="p">)])</span> <span class="p">::</span> <span class="n">content</span><span class="p">)</span> <span class="p">=&gt;</span>
        <span class="k">def</span> <span class="nf">parse_content</span> <span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="p">{</span>
	  <span class="k">match</span> <span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="p">{</span>
	    <span class="p">|</span> <span class="n">x</span> <span class="p">::</span> <span class="n">xs</span> <span class="p">=&gt;</span>
	      <span class="n">RefrigeratorContent</span><span class="p">.</span><span class="n">FromXml</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">::</span> <span class="n">parse_content</span> <span class="p">(</span><span class="n">xs</span><span class="p">)</span>
	    <span class="p">|</span> <span class="p">[]</span> <span class="p">=&gt;</span> <span class="p">[]</span>
	  <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">Refrigerator</span> <span class="p">(</span><span class="kt">float</span><span class="p">.</span><span class="n">Parse</span> <span class="p">(</span><span class="n">min_temp</span><span class="p">),</span> <span class="n">parse_content</span> <span class="p">(</span><span class="n">content</span><span class="p">));</span> <span class="c1">// (*)</span>
      <span class="p">|</span> <span class="n">_</span> <span class="p">=&gt;</span>
        <span class="k">throw</span> <span class="n">System</span><span class="p">.</span><span class="n">ArgumentException</span> <span class="p">(</span><span class="s">"node"</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>


<p>The reader will easily note that: &#xD;
a) the XML deserialization code looks a bit like a junk &#xD;
b) it can be generated automatically, and &#xD;
c) without matching it would be even worse. &#xD;
Later we will learn how to write macros to generate this kind of &#xD;
code automatically.&#xD;</p>

<p>We can however still make it somewhat better, without resorting to &#xD;
macros. First off, if you wrote the <code>map</code> example from the &#xD;
previous week, then the <code>parse_content</code> function should &#xD;
familiar to you. In fact it can be replaced with <code>map</code> &#xD;
altogether, like this:&#xD;</p>

<div class="highlight"><pre><span class="n">Refrigerator</span> <span class="p">(</span><span class="kt">float</span><span class="p">.</span><span class="n">Parse</span> <span class="p">(</span><span class="n">min_temp</span><span class="p">),</span> <span class="n">map</span> <span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">RefrigeratorContent</span><span class="p">.</span><span class="n">FromXml</span><span class="p">));</span>
</pre>
</div>


<p>We have passed a static global function as a functional value. &#xD;
It works exactly the same as with local functions.&#xD;</p>

<p>Because the <code>map</code> function is generally useful, it is included &#xD;
in the standard library as a member function of the <code>list</code> &#xD;
data structure. So we remove <code>parse_content</code>, and replace line &#xD;
marked by <code>(*)</code> with:&#xD;</p>

<div class="highlight"><pre><span class="n">Refrigerator</span> <span class="p">(</span><span class="kt">float</span><span class="p">.</span><span class="n">Parse</span> <span class="p">(</span><span class="n">min_temp</span><span class="p">),</span> <span class="n">content</span><span class="p">.</span><span class="n">Map</span> <span class="p">(</span><span class="n">RefrigeratorContent</span><span class="p">.</span><span class="n">FromXml</span><span class="p">));</span>
</pre>
</div>


<h3><span class="mw-headline" id="Side_note_skipping_codematchcode"><a name="Side_note_skipping_codematchcode" id="Side_note_skipping_codematchcode">Side note: skipping <code>match</code></a></span></h3>

<p>Because it is quite a common pattern to do matching directly on&#xD;
arguments, Nemerle provides a way to skip <code>match</code> in such &#xD;
cases. If your function starts with <code>|</code> it is implicitly &#xD;
surrounded with <code>match (single_parm) { ... }</code>, or in the &#xD;
case there is more than one parameter, with <code>match ((parm1, parm2, ..., parmN)) { ... }</code>&#xD;
(so you can use tuple patterns to get to a particular parameter).&#xD;
So we can further shorten the above example by two more lines:&#xD;</p>

<div class="highlight"><pre><span class="k">public</span> <span class="k">static</span> <span class="nf">FromXml</span> <span class="p">(</span><span class="n">node</span> <span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="p">:</span> <span class="n">Refrigerator</span>
<span class="p">{</span>
  <span class="p">|</span> <span class="n">Element</span> <span class="p">(</span><span class="s">"refrigerator"</span><span class="p">,</span> 
      <span class="n">Element</span> <span class="p">(</span><span class="s">"minimal-temperature"</span><span class="p">,</span> <span class="p">[</span><span class="n">Text</span> <span class="p">(</span><span class="n">min_temp</span><span class="p">)])</span> <span class="p">::</span> <span class="n">content</span><span class="p">)</span> <span class="p">=&gt;</span>
    <span class="n">Refrigerator</span> <span class="p">(</span><span class="kt">float</span><span class="p">.</span><span class="n">Parse</span> <span class="p">(</span><span class="n">min_temp</span><span class="p">),</span> <span class="n">content</span><span class="p">.</span><span class="n">Map</span> <span class="p">(</span><span class="n">RefrigeratorContent</span><span class="p">.</span><span class="n">FromXml</span><span class="p">));</span>
  <span class="p">|</span> <span class="n">_</span> <span class="p">=&gt;</span>
    <span class="k">throw</span> <span class="n">System</span><span class="p">.</span><span class="n">ArgumentException</span> <span class="p">(</span><span class="s">"node"</span><span class="p">)</span>
<span class="p">}</span>
</pre>
</div>


<h2><span class="mw-headline" id="Exercises"><a name="Exercises" id="Exercises">Exercises</a></span></h2>

<h3><span class="mw-headline" id="Exercise_1_TreeIter"><a name="Exercise_1_TreeIter" id="Exercise_1_TreeIter">Exercise 1: Tree.Iter</a></span></h3>

<p>Add an <code>Iter (f : int -&gt; void) : void</code> method to the <code>Tree</code>&#xD;
variant, implementing inorder traversal (that is you first traverse the left&#xD;
subtree, then call f on current element, and traverse the right subtree).&#xD;</p>

<h3><span class="mw-headline" id="Exercise_2_XML_parsing"><a name="Exercise_2_XML_parsing" id="Exercise_2_XML_parsing">Exercise 2: XML parsing</a></span></h3>

<p>Write a function that reads XML from specified&#xD;
files and puts it into the <code>Node</code> variant defined above. Then write a&#xD;
function to dump your data in a lispy format, something like:&#xD;</p>

<pre>&#xD;(tree&#xD;(branch&#xD;(leaf)&#xD;)&#xD;(branch&#xD;($text "Foo")&#xD;)&#xD;)&#xD;</pre>&#xD;

<p>Then you can implement indentation of output.&#xD;</p>

<pre>&#xD;(tree&#xD;  (branch&#xD;    (leaf))&#xD;  (branch&#xD;    ($text "Foo")))&#xD;</pre>&#xD;

<p>Then copy the refridgerator variants from the above, fix any errors you find in&#xD;
them and try to parse the following file:&#xD;</p>

<p>&lt;xml&gt;&lt;?xml version='1.0' encoding='utf-8' ?&gt;&#xD;&amp;lt;refrigerator&amp;gt;&#xD;  &amp;amp;lt;minimal&amp;amp;#45;temperature&amp;amp;gt;&amp;amp;#45;3.0&amp;amp;lt;/minimal&amp;amp;#45;temperature&amp;amp;gt;&#xD;  &amp;amp;lt;beer&amp;amp;gt;&#xD;    &amp;amp;amp;lt;name&amp;amp;amp;gt;Hyneken&amp;amp;amp;lt;/name&amp;amp;amp;gt;&#xD;    &amp;amp;amp;lt;volume&amp;amp;amp;gt;0.6&amp;amp;amp;lt;/volume&amp;amp;amp;gt;&#xD;  &amp;amp;lt;/beer&amp;amp;gt;&#xD;  &amp;amp;lt;beer&amp;amp;gt;&#xD;    &amp;amp;amp;lt;name&amp;amp;amp;gt;Bydweisser&amp;amp;amp;lt;/name&amp;amp;amp;gt;&#xD;    &amp;amp;amp;lt;volume&amp;amp;amp;gt;0.5&amp;amp;amp;lt;/volume&amp;amp;amp;gt;&#xD;  &amp;amp;lt;/beer&amp;amp;gt;&#xD;  &amp;amp;lt;beer&amp;amp;gt;&#xD;    &amp;amp;amp;lt;name&amp;amp;amp;gt;Plsner&amp;amp;amp;lt;/name&amp;amp;amp;gt;&#xD;    &amp;amp;amp;lt;volume&amp;amp;amp;gt;0.5&amp;amp;amp;lt;/volume&amp;amp;amp;gt;&#xD;  &amp;amp;lt;/beer&amp;amp;gt;&#xD;  &amp;amp;lt;chips&amp;amp;gt;&#xD;    &amp;amp;amp;lt;weight&amp;amp;amp;gt;500&amp;amp;amp;lt;/weight&amp;amp;amp;gt;&#xD;  &amp;amp;lt;/chips&amp;amp;gt;&#xD;  &amp;amp;lt;ketchup&amp;amp;gt;&amp;amp;lt;/ketchup&amp;amp;gt;&#xD;&amp;lt;/refrigerator&amp;gt;&#xD;&lt;/xml&gt;&#xD;</p>

<p>Warning: you do not need to write the XML parser. You should not do&#xD;
it, actually. Use the <a target="_blank" href="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfsystemxml.asp">System.Xml</a> namespace from the .NET Framework. In&#xD;
order to link with the System.Xml library you need to compile with the&#xD;
<code>-r:System.Xml</code> option. For example:&#xD;</p>

<pre>  ncc -r System.Xml myprogram.n&#xD;</pre>

<p>should do.&#xD;
&#xD;</p>

                                </div>
                        </td>
                        <td width="100px">
                            &nbsp;
                        </td>
                    </tr>
                </tbody></table>
            </td>
        </tr>
            <tr class="footer">
                <td>
                    <table border="0" cellpadding="0" cellspacing="0">
                        <tbody><tr>
                            <td colspan="2">
                                &nbsp;&nbsp;© 2011 <a href="http://code.google.com/p/nemerle/people/list">Nemerle Project Team</a>&nbsp;&nbsp;This site is hosted and maintained by <a href="http://rsdn.ru/">Russian Software Development Network</a> team
                            </td>
                            <td width="100px" align="right">
                                <a href="http://www.opensource.org/licenses/bsd-license.php">Legal&nbsp;statements</a>&nbsp;&nbsp;
                            </td>
                        </tr>
                    </tbody></table>
                </td>
            </tr>
            <tr class="shadow">
                <td>
                    <table border="0" cellpadding="0" cellspacing="0">
                        <tbody><tr>
                            <td width="100px"></td>
                            <td class="shadow">
                                <img src="./static/shadow-foreground.png">
                            </td>
                            <td width="100px"></td>
                        </tr>
                    </tbody></table>
                </td>
            </tr>
        </tbody></table>
</body></html>